1로 만들기 <dp문제>

1. 구상
    1. 알고리즘을 모르고 봤을때 재귀로 풀어야겠다고 생각했지만 시간제한을 보고는 재귀로는 안되겠다고 생각.
    2. 그래도 재귀로 구성을 해봤음
    3. 시간복잡도가 너무 커져서 dp로 해야겠다는 생각
    4. 하지만 dp는 피보나치처럼 규칙이 있어야 만들수 있는데 이건 도대체 어떤 규칙이 있는건지 막막..

2. 해결
    1. 결국 구글링 해본 결과 dp[max] 라는 배열을 만들어서 n의 범위 1<= n <= 1000000을 삽입 dp[n]하여
    1부터 1000000까지 경우를 dp[n]에 넣어서 규칙을 찾아봄
    2. dp[1]은 0, dp[2] = 1, dp[3] = 1 .... 등이 있고
    반복문이 도는데 n값의 조건에따라 경우를 나눠줬음
        1. n이 2와 3 모두 안나눠 떨어질때
        -> 무조건 -1 하면 dp[n] = dp[n - 1] + 1
        2. n이 2와 3 둘다 나눠 떨어질때
        3. n이 2로만 나눠 떨어질때
        4. n이 3으로만 나눠 떨어질때
    3. dp[n] = dp[n / 2] + 1 , dp[n] = dp[n / 3] + 1 
    이 식이 dp의 해결 키포인트였음

3. 결론
    1. dp문제는 반복문 안에서 조건을 찾는다.
    2. 키포인트는 dp 배열에서 인덱스에 조건 n을 박는다.
    3. 그 조건 n에 /2 /3 -1 등이 삽입이 된다.
